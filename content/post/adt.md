+++
title = "دیتا تایپ‌های جبری (‌‌ADT)"
date  = "2018-02-06"
jdate = "۱۳۹۶/۱۱/۲۱"
draft = false

postdesc = "تشریح مفهوم دیتا تایپ های جبری"
postkeywords = "تایپ, تایپ سیستم, جبری, ضرب, جمع, زبان, برنامه نویسی, استاتیک"
topic = ["برنامه نویسی"]

+++


<a name="toc"></a>
## فهرست مطالب

- [مقدمه][intro]
- [هر تایپ، یک مجموعه است][type-is-set]
- [دیتا تایپ جبری][adt]
- [ضرب یا Product][product-type]
- [جمع یا Sum][sum-type]
- [تایپ Option][option-type]
- [سخن آخر][end]



<a name="intro"></a><a name="مقدمه"></a>
## مقدمه

مدتی پیش یک پست بُلندبالا نوشتم و تعدادی از مفاهیم مربوط به تایپ سیستم‌ها را در آن شرح دادم؛ اما یکی از مهم‌ترین مفاهیمی که باید در آن پست قرار می‌دادم را از قلم انداختم. دلیل اصلی‌اش هم این بود که فکر می‌کردم این مفهموم آنقدر مهم هست که باید یک پست مجزا را به آن اختصاص دهم. 

«دیتا تایپ‌های جبری» یا Algebraic Data Types (که با نام اختصاری ADT) شناخته می‌شوند، از مهم‌ترین و پایه‌ای ترین مفاهیم تایپ سیستم‌ها هستند که متاسفانه خیلی از برنامه‌نویسان آشنایی مناسبی با آن‌ها ندارند؛ این قضیه هم مختص برنامه‌نویسان ایرانی نیست. نکته‌ی عجیب ماجرا اینجاست که تقریبا تمام برنامه‌نویسان کم و بیش با این تایپ‌ها سر و کار داشته اند.

دیتا تایپ‌های جبری با زبان ML معروف شدند؛ و هر زبانی که به نوعی ایده‌هایی از ML را در خود دارد نیز کم و بیش دارای دیتا تایپ‌های جبری می‌باشد. زبان‌هایی مانند Haskell ، Scala، Rust، Swift، Clojure، Erlang/Elixir، Ocaml، TypeScript و... برای همین تصمیم گرفتم مطابق مطالب پیشین این وبلاگ، در این پست به زبانی ساده مفهموم دیتا تایپ‌های جبری را شرح دهم.

<a name="type-is-set"></a><a name="هر تایپ، یک مجموعه است"></a>
## هر تایپ، یک مجموعه است

در مقاله‌ی مربوط به «مفاهیم بنیادین تایپ سیستم‌ها»، مفهوم «تایپ» را به این صورت تعریف کردیم:

«خصوصیتی است که تعیین می‌کند یک «داده»، می‌تواند شامل چه «محتوا» ای باشد و چه کارهایی می‌توان با آن انجام داد».

فرضا وقتی می‌گوییم متغیر A از تایپ int است منظورمان چیست؟ یعنی متغیر A می‌تواند شامل «یکی» از حالاتی باشد که از طرف تایپ int قابل ارائه است.

**سوال: تایپ int چه حالاتی را ارائه میکند؟**

با فرض بر اینکه int را از نوع ۳۲بیتی در نظر گرفته باشیم، مقادیر قابل ارائه در تایپ int یکی از اعدادی خواهد بود که بین منفی 2147483648 تا مثبت 2147483647 هستند. میتوان اینطور گفت که int در واقع بیان کننده‌ی «مجموعه» مقادیری است که بین این دو عدد قرار دارد. اگر بخواهیم به زبان ریاضی توضیح دهیم یعنی این:

```
int = {-2147483648, -2147483647, -2147483646, . . . , 2147483647}
```

چنین تعریفی برای بقیه تایپ‌ها نیز صدق می‌کند. مثلا تایپ string شامل «مجموعه»ای است که از تمام کاراکترهای یونیکد تشکیل شده است. یا مثلا تایپ bool یا boolean شامل «مجموعه» ای دو عضوی است: true یا false

<span class="in-red">
پس هر تایپ، در قالب یک «مجموعه» قابل تعریف است. (Set)
</span>

<a name="adt"></a><a name="دیتا تایپ جبری"></a>
## دیتا تایپ جبری

از آنجایی که هر تایپ یک مجموعه است، پس قادر هستیم عملیات جبری مربوط به مجموعه‌ها مثل «اشتراک» و «اجتماع» و ... را روی آن‌ها اعمال کنیم! بنابراین دیتا تایپ‌های جبری را می‌توان اینچنین تعریف کرد:

<span class="in-red">
«تایپ‌هایی که می‌توانیم عملیات‌های جبری مربوط به مجموعه‌ها را روی آن‌ها اعمال کنیم. در این تعریف، منظورمان از عملیات جبری مشخصا عمل «ضرب» و «جمع» می‌باشد.»
</span>

در تعریف بالا:

- منظورمان از «ضرب»، همان «ضرب دکارتی» است که به انگلیسی با عنوان Product یا Cartesian product شناخته می‌شود.
- و منظورمان از «جمع»، همان «اجتماع» یا Union است.

من خودم با اینکه ارزش بسیار زیادی برای ریاضیات قائل هستم، اما هیچوقت در آن خوب نبودم! بنابراین مطمئن باشید که این تعاریف را به ساده‌ترین حالت ممکن توضیح خواهم داد.

<a name="product-type"></a><a name="ضرب یا Product"></a>
## ضرب یا Product
همانطور که گفتیم در این مقاله منظورمان از «ضرب»، همان ضرب دکارتی است. 

تعریف ضرب دکارتی:

اگر دو مجموعه داشته باشیم به نام‌های A و B ، حاصلضرب دکارتی این دو مجموعه را با نماد  A × B نشان خواهیم داد؛ و نتیجه‌ی آن برابر است با مجموعه‌ای که عضوهایش شامل تمام ترکیباتی باشد که عنصر اول آن از اعضای A انتخاب شده باشد و عنصر دیگر آن از اعضای B باشد.

مثال:

```
A = { x, y }

B = { 3, 4, 5 }

A × B = { (x , 3), (x , 4), (x , 5),
          (y , 3), (y , 4), (y , 5) }
```

دقت کنید اعضای مجموعه‌ی نهایی که از حاصلضرب دکارتی دو مجموعه‌ی اول بدست آمده‌اند، هر کدام در قالب یک «ترکیب» در مجموعه حاضر شده‌اند. مثلا مانند (x , 3). 

اگر همین تعاریف را بخواهیم در برنامه‌نویسی وارد کنیم، میگوییم که:

<span class="in-red">
اگر یک «پروداکت تایپ» داشته باشیم، مقدار مورد قبول آن می‌تواند «یکی» از عناصر ترکیبی ای باشد که در مجموعه حالات آن تایپ تعریف شده است.
</span>

این «ترکیب» ای که از آن حرف می‌زنیم، معمولا در زبان‌های برنامه‌نویسی توسط ساختار‌های ترکیبی مانند struct یا class یا tuple معرفی خواهند شد. مثلا میخواهیم یک تایپ تعریف کنیم که وضعیت حضور و غیاب و شماره صندلی دانش آموزان را با آن بیان نماییم. میتوانیم این تایپ را به شکل یک پرداکت تایپ تعریف کنیم. کد آن در زبان C چیزی شبیه این خواهد بود:

```
typedef struct {
   bool   present;
   int    seatNumber;
} ClassRoomStudent;
```

و در قسمت‌های دیگر کدهای خود می‌توانیم به چنین شکلی از این تایپ استفاده کنیم:

```
ClassRoomStudent sara  = {true  , 12};
ClassRoomStudent john  = {true  ,  5};
ClassRoomStudent steve = {false , 18};

if (sara.present) {
  printf("Sara is here and her seat number is: %d", sara.seatNumber);
}
``` 

دقت کنید که متغیرهای sara یا john چگونه به صورت ترکیبی بیان شده اند... این ترکیب برابر است با همان ترکیبی که در پرداکت تایپ ClassRoomStudent مشخص کرده بودیم.

**سوال: مجموعه مقادیری که پروداکت تایپ ClassRoomStudent میتواند ارائه کند چیست؟**

- عنصر اول از تایپ ClassRoomStudent برابر با bool است و bool شامل دو عضو true یا false می‌باشد. 
- عنصر دوم از تایپ ClassRoomStudent برابر با int است و int شامل 4294967296 رقم مختلف است که بین اعداد منفی 2147483648 تا مثبت 2147483647 قرار دارند.

بنابراین مجموعه حالات ClassRoomStudent برابر مجموعه‌ی زیر است:

```
ClassRoomStudent = { (true , -2147483648), (true , -2147483647), . . ., (false , 2147483647) }
```

اگر تا الآن برایتان سوال بود که کامپایلر چگونه مقادیر مربوط به تایپ‌های شما را از نظر درستی چک میکند، حالا دیگر جواب آن را می‌دانید. کامپایلر مقداری که عنوان کرده اید را بررسی میکند و جویای این می‌شود که آیا مقدار شما جزو مجموعه‌ی مقادیر تایپ مورد نظرتان هست یا خیر. در حقیقت اعمال ریاضی مربوط به تئوری مجموعه‌ها در حال انجام کارتان هستند!
 
**سوال: وقتی میگوییم یک زبان برنامه‌نویسی از دیتا تایپ‌های جبری پشتیبانی می‌کند منظورمان چیست؟**

یعنی زبان مورد نظر ما به طور درونی، تایپ‌های جبری را به رسمیت می‌شناسد و برای آن سینتکس مشخصی ارائه کرده است. فرضا در مثال بالا ما یک پروداکت تایپ در زبان C ایجاد کردیم. اگر همین کار را میخواستیم در زبانی مانند Haskell انجام دهیم که از دیتا تایپ‌های جبری برخوردار است، کد ما فقط همین یک خط تمیز و ساده‌ای می‌شد که می‌بینید:

```
data ClassRoomStudent = S Bool Int
```

<a name="sum-type"></a><a name="جمع یا Sum"></a>
## جمع یا Sum

بالاتر اشاره کردیم که منظورمان  از «جمع»، همان «اجتماع» یا Union است. (در برنامه‌نویسی با گونه‌ای از Union ها به اسم Tagged union بیشتر طرف خواهید شد.)

تعریف اجتماع:

اگر دو مجموعه داشته باشیم به نام‌های A و B ، اجتماع این دو مجموعه را با نماد  A ∪ B  نشان خواهیم داد؛ و نتیجه‌ی آن برابر است با مجموعه‌ای که اعضایش «یا» در A هستند، «یا» در B هستند، و «یا» در هردوی آن‌ها. (حواس‌تان باشد که روی «یا» حساسیت به خرج داده ام!)

مثال:

```
A = { x, y }

B = { 3, 4, 5 }

A ∪ B = { x, y, 3, 4, 5 }
```

بر خلاف پرداکت، اینجا میبینید که اعضای مجموعه‌ی نهایی به صورت فردی و تنها ظاهر شده‌اند.

اگر همین تعاریف را بخواهیم در برنامه‌نویسی وارد کنیم، میگوییم که:

<span class="in-red">
اگر یک «سام تایپ» داشته باشیم، مقدار مورد قبول آن می‌تواند «یکی»، و **فقط «یکی»**، از عناصری باشد که در مجموعه حالات آن تایپ تعریف شده است.
</span>

سام تایپ‌ها در اغلب زبان‌های برنامه‌نویسی توسط ساختار enum معرفی می‌شوند. ساختار enum می‌تواند مجموعه‌ای از مقادیر را تعریف کند که در هر لحظه فقط یکی از آن‌ها می‌توانند فعال باشند. مثلا میخواهیم یک تایپ تعریف کنیم که از روی رنگ، استقلالی یا پرسپولیسی بودن یک شخص را با آن بیان کنیم. می توانیم این تایپ را به شکل یک سام تایپ تعریف کنیم. کد آن در زبان جاوا چیزی شبیه این خواهد بود:

```
enum Color {
  Red,
  Blue,
  Purple
}
```

و در قسمت‌های دیگر کدهای خود می‌توانیم به چنین شکلی از این تایپ استفاده کنیم:

```
Color c = Color.Red;

switch (c) {

case Red:
  System.out.println("Persepolis, yay!");
  break;

case Blue:
  System.out.println("Esteghlal, yay!");
  break;
  
case Purple:
  System.out.println("Hassan Kelid Saaz, yay!");
  break;
}
```

دقت کنید که متغیر c می‌توانید یا Red باشد، یا Blue باشد، و یا Purple باشد. یعنی در هر لحظه می‌تواند فقط یکی از این حالات را داشته باشد.

بر اساس این خاصیت، شما می‌توانید تایپی مانند int را هم مثل یک enum بسیار بزرگ در نظر بگیرید که اعداد به صورت ردیفی در آن لحاظ شده‌اند و متغیر int شما می‌تواند یکی از آن اعداد باشد!

غالبا پیش از استفاده از سام تایپ‌ها، ابتدا نیاز پیدا خواهید کرد مقداری که در حال حاضر فعال است را شناسایی کنید. این کار توسط if یا select یا switch انجام می‌پذیرد. و شما با توجه به اینکه کدام یکی از آن مقادیر فعال هستند، عکس العمل مناسب را نشان خواهید داد.

در زبان‌های برنامه نویسی مدرن‌تر و به خصوص زبان‌های فانکشنال، قابلیت «تطبیق الگو» یا Pattern Matching در زبان حضور دارد که شما را از هرچه if و switch و امثال‌شان است خلاص می‌کند و کدهایی تمیزتر و قابل فهم تر تولید می‌نماید. سام تایپ‌ها و مکانیزم تطبیق الگو، به نوعی لازم و ملزوم یکدیگر هستند.

در زبانی مثل Haskell، سام تایپِ  Color به این شکل تعریف می‌شد:

```
data Color = Red | Blue | Purple
```

همانطور که متوجه شدید سام تایپ‌ها بسیار اساسی هستند و کامپایلر برای چک کردن خیلی از تایپ‌ها از این اعمال ریاضی استفاده می‌کند؛ اما یک سام تایپ بسیار معروف هست که می‌دانم خیلی از شما اسم آن را شنیده‌اید... تایپ Option

<a name="تایپ Option"></a><a name="option-type"></a>
## تایپ Option

این تایپ از شناخته شده ترین و پرکاربرد ترین سام تایپ‌هایی است که در اکثر زبان‌های برنامه‌نویسی حضور دارد. در بعضی زبان‌ها اسمش Option است، در بعضی دیگر با اسم Optional شناخته می‌شود، و گاهی هم آن را Maybe صدا می‌زنند.

شمایل این تایپ در زبان Swift اینگونه است:

```
enum Optional<T> {
  case some(T)
  case none
}
```

یا فرضا در زبان Rust اینگونه تعریف شده است:

```
pub enum Option<T> {
    None,
    Some(T),
}
```

تعریف بالا یعنی Option دو حالت را ارائه خواهد که در هر لحظه فقط یکی از حالات می‌تواند وجود داشته باشد:

- حالت None که یعنی هیچ چیزی وجود ندارد.
- حالت Some که یعنی یک مقدار که دارای تایپِ T است در دسترس است و توسط Some کپسوله شده است.

حالا چنین چیزی در چه زمان‌هایی ممکن است بدرد بخورد؟ تایپ Option بیشتر برای هندل کردن خطاها کاربرد پیدا می‌کند. خیلی از مواقع توابعی دارید که در صورت موفقیت، مقدار مناسبی را بر‌میگردانند؛ و در صورت ناموفق بودن، ایجاد خطا خواهند کرد.

مثلا تابعی دارید که دو عدد را به عنوان آرگومان می‌پذیرد، و نتیجه‌ی تقسیم آن دو عدد بر یکدیگر را برمیگرداند. خطایی که ممکن است پیش بیاید این است که اعداد بر صفر تقسیم نخواهند شد بنابراین پارامتر دوم نمی‌تواند صفر باشد. پس یکی از دو اتفاق زیر ممکن است در این تابع صورت بگیرد (و شما مطمئن نیستید کدام!):

- یا رقم دوم صفر خواهد بود. که در این صورت تابع خطا خواهد داشت.
- یا تقسیم بدون مشکل انجام می‌شود و نتیجه به درستی برگشت داده خواهد شد.

حالا با این توضیحات، تایپ خروجی تابع را باید چگونه انتخاب کنیم؟ در حالت عادی، میتوانیم بگوییم که خروجی این تابع یک مقدار اعشاری است. اما می‌دانیم که همیشه اینطور نخواهد بود. این حس «مطمئن نبودن» را چگونه می‌خواهید برای تایپ سیستم توضیح دهید؟

اینجاست که شما می‌توانید از تایپ Option استفاده کنید! یعنی تایپِ خروجی این تابع را از نوع Option انتخاب می‌کنید و با اینکار به کامپایلر می‌گویید که این تابع هم ممکن است خطا بدهد و هم ممکن است بدون ایراد کار کند. تعریف چنین تابعی در زبانی مثل Rust اینگونه است:

```
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None           // Fail, without panic!
    } else {
        Some(a / b)    // Wrap division result in Some(), and return it.
    }
}
```

و در قسمت‌های دیگر کدهای خود می‌توانیم به این شکل از این تابع استفاده کنیم:

```
match divide(12, 0) {
  None => {
    println!("error: could not do this division!")
  },
  Some(result) => {
      println!("result is: {}", result)
  },
}
```

اگر تابع بالا را اجرا کنید، برنامه بدون اینکه وسط کار کرش کند، براحتی خطای صورت گرفته را متوجه می‌شود و توضیح مناسبی برای آن چاپ خواهد کرد.  ده‌ها مورد دیگر از این موارد وجود دارند که شما از وجود یک مقدار نهایی اطمینان کافی ندارید و می‌توانید با استفاده از تایپ Option خیال خود را از وقوع اتفاقات نامطلوب در چنین شرایطی راحت کنید.

<a name="end"></a><a name="سخن آخر"></a>
## سخن آخر
دیتا تایپ‌های جبری، اساسی و جذاب هستند! وجود پشتیبانی مناسب از آن‌ها در یک زبان برنامه‌نویسی، می‌تواند امنیت کدهایتان را بسیار بالا ببرد. فرضا همین تایپ Option که بالاتر درباره‌اش توضیح دادیم، می‌تواند شما را از خطاهای مربوط به مقادیر null خلاص کند! در بین زبان‌های مختلف اشتیاق مناسبی برای پشتیبانی بهتر از این تایپ‌ها وجود دارد. فرضا جاوا ۸ همین تایپ Optional را به زبان اضافه کرد. یا مثلا TypeScript دیتا تایپ‌های جبری را در ورژن ۲ به زبان اضافه کرده تا شما در دنیای بی بند و بار جاوا اسکریپت هم بتوانید به مزایای این تایپ‌ها دسترسی داشته باشد. از همین رو مطالعه‌ی دیتا تایپ‌های جبری برای تمام برنامه‌نویسان سودمند خواهد بود.




[intro]: #intro
[type-is-set]: #type-is-set
[adt]: #adt
[product-type]: #product-type
[sum-type]: #sum-type
[option-type]: #option-type
[end]: #end


